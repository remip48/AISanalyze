% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/00_AIStravel_interpolate_extract.R
\name{AIStravel_interpolate_extract}
\alias{AIStravel_interpolate_extract}
\title{Run AIStravel, AIScorrect_speed, AISinterpolate_at and AISextract together in an optimized way.
Used to extract AIS data in the radius of an input data with location and time.}
\usage{
AIStravel_interpolate_extract(
  data,
  ais_data,
  mmsi_time_to_order = T,
  search_into_radius_m = 50000,
  run_AIStravel = T,
  save_AIStravel = T,
  file_AIStravel = "AIStravel",
  load_existing_files = F,
  overwrite = F,
  time_stop = 5 * 60 * 60,
  run_AISinterpolate_at = T,
  save_AISinterlate_at = T,
  file_AISinterlate_at = "AISinterpolate_at",
  correct_speed = T,
  threshold_speed_to_correct = 100,
  threshold_speed_to_correct_expr = function(speed_kmh) {
    
    return((median(speed_kmh[speed_kmh > 1], na.rm = T) + sd(speed_kmh[speed_kmh > 1 &
    speed_kmh < quantile(speed_kmh[speed_kmh > 1], 0.75)]) * 5 + 15))
 },
  crs_meters = 3035,
  duplicate_time = T,
  max_time_diff = 1 * 60 * 60,
  t_gap = 2 * 60,
  accelerate = T,
  average_at = 30,
  filter_station = T,
  filter_high_speed = T,
  radius = 2e+05,
  quantile_station = 0.975,
  threshold_distance_station = 1,
  quantile_high_speed = 0.97,
  threshold_high_speed = 110,
  run_AISextract_perHour = T,
  save_AISextract_perHour = T,
  file_AISextract_perHour = "AISextract",
  return_merged_all_extracted = T,
  parallelize = F,
  nb_cores = NA,
  outfile = "log.txt",
  QUIET = F
)
}
\arguments{
\item{data}{Data of interest for the extraction of AIS. Must contain a column: timestamp (number of seconds since January 1, 1970 (the Unix epoch): see https://r-lang.com/how-to-convert-date-to-numeric-format-in-r/ for transformation), and the columns lon (longitude) & lat (latitude). timestamp, lon and lat must be numeric.}

\item{ais_data}{AIS data. Must contain a column: timestamp (number of seconds since January 1, 1970 (the Unix epoch): see https://r-lang.com/how-to-convert-date-to-numeric-format-in-r/ for transformation), and the columns lon (longitude), lat (latitude) and mmsi (Maritime mobile service identity). timestamp, lon and lat must be numeric. The mmsi column is the identifier for the vessels, the values can be replaced by the IMO or another identifier, but the name of the column must be mmsi.}

\item{mmsi_time_to_order}{if MMSI and timestamps are not yet arranged as dplyr::arrange(AIS data, mmsi, timestamp), must be TRUE. We recommand to put it as TRUE by precaution. Important to prevent large errors.}

\item{search_into_radius_m}{radius (kilometer) where the MMSIs are extracted and returned.}

\item{run_AIStravel}{if the AIS data must be ran with AIStravel function firstly or not. If already processed with AIStravel, probably not.}

\item{save_AIStravel}{if results from AIStravel must be saved (only if run_AIStravel = T).}

\item{file_AIStravel}{if save_AIStravel = TRUE, is the file name where AIStravel output is saved. Must not contain file format: the files are written as .rds.}

\item{load_existing_files}{if TRUE, load the existing files (saved during previous runs) of AIStravel, AISinterpolate_at and AISextract when running the functions.}

\item{overwrite}{if TRUE, the saved files (see save_AIStravel, save_AISinterlate_at, save_AISextract_perHour) overwrite existing files. Otherwise load the existing files if these are existing and needed in the function.}

\item{time_stop}{number of seconds before and after the AIS signal were the vessel track is not calculated/interpolated anymore if there is not another AIS signal meanwhile. Filter also AIS data too long before and after that are not of interest, to accelerate a lot the process.}

\item{run_AISinterpolate_at}{if the AIS data must be ran with AISinterpolate_at function firstly or not. If already processed with AISinterpolate_at, probably not.}

\item{save_AISinterlate_at}{if TRUE, save the results for each iteration of hour of AIS data (only if run_AISinterpolate_at = T). The saved results should not be used outside of this function as they are not complete yet! Please re-run these function to have the full interpolated data.}

\item{file_AISinterlate_at}{if save_AISinterlate_at = TRUE, is the file name where hourly interpolated AIS data are saved. Must not contain file format: the files are written as .rds.}

\item{correct_speed}{if TRUE, GPS errors and GPS delays are identified and removed from AIS data. Vessel speeds, distance and time travelled are corrected. Usually necessary.}

\item{threshold_speed_to_correct}{speeds higher than this threshold are corrected if the mmsi is not an aircraft and if correct_speed = T}

\item{threshold_speed_to_correct_expr}{expression (function having "speed_kmh" as unique parameter) to determine another threshold correcting GPS errors and delays. This expression is ran for each MMSI individually, allowing to identify unrealistic speeds based on the mean of the vessel speed, median, standard deviation or other functions. The default expression has been tested as relevant and appropriate to filter GPS errors and delays, still checks are necessary.}

\item{crs_meters}{projection (crs) in 'meters' to use to calculate distance over the study area. Default to 3035 (ETRS89).}

\item{duplicate_time}{if TRUE, extend (and duplicate) the data to past timestamps, to investigate the past presence of vessels at the data locations: extend the data timestamps up to "max_time_diff" number of seconds before the timestamps, by steps of "t_gap" number of seconds.}

\item{max_time_diff}{if duplicate_time = TRUE, extend (and duplicate) the data to past timestamps, to investigate the past presence of vessels at the data locations: extend the data timestamps up to "max_time_diff" number of seconds before the timestamps, by steps of "t_gap" number of seconds.}

\item{t_gap}{see "max_time_diff". Is also used as the number of seconds before and after the data timestamps where vessels are considered for extraction (otherwise other AIS data are filtered out).}

\item{accelerate}{if TRUE, data timestamps are averaged at "average_at" seconds to decrease the number of data timestamp to process and  strongly decrease the computation time.}

\item{average_at}{if accelerate = TRUE, the data timestamps are approximated to within to "average_at" number of seconds. This, to decrease the number of data timestamps to process. Necessary for large data timestamps to extract. Is also used as the number of seconds before and after the data timestamps where vessels are considered for extraction, in addition to "t_gap" parameter (otherwise other AIS data are filtered out).}

\item{filter_station}{if TRUE, filter the stations out.}

\item{filter_high_speed}{if TRUE, filter the aircraft out.}

\item{radius}{radius (meters) around data where AIS data are considered for interpolation of the positions. Must be large enough to collect the AIS data necessary for a linear interpolation at the time of the data. Is used also to filter the AIS data too far from the data of interest and slowing the processes (we used 200 km as default value of radius).}

\item{quantile_station}{Quantile (0 to 1) of distance, by mmsi, which is compared to threshold_distance_station to assess if the MMSI is a station or not: if below threshold_distance_station, MMSI is considered as stationary and is a station. We used 0.975 to prevent misinterpretations from GPS errors leading to distance travelled by stations.}

\item{threshold_distance_station}{Threshold of distance (meters) used to assess if the MMSI is a station.}

\item{quantile_high_speed}{Quantile (0 to 1) of speed, by mmsi, which is compared to threshold_high_speed to assess if the MMSI is a aircraft or not: if above threshold_high_speed, MMSI is considered as a station. We used 0.97 to prevent misinterpretations from GPS errors.}

\item{threshold_high_speed}{Threshold of speed (km/h) used to assess if the MMSI is an aircraft.}

\item{run_AISextract_perHour}{if the AIS data must be extract for the locations & times of the data (ran with AISextract), up to "max_time_diff" number of seconds before the data timestamps by steps of "t_gap".}

\item{save_AISextract_perHour}{if results from AISextract must be saved, (only if run_AISextract_perHour = T).}

\item{file_AISextract_perHour}{if save_AISextract_perHour = TRUE, is the file name where hourly extracted AIS data along data of interest are saved. Must not contain file format: the files are written as .rds.}

\item{return_merged_all_extracted}{if TRUE, return the output (from AISextract, AISinterpolate_at, or AIStravel by order of process). Otherwise, return NULL. Usefull if the results are saved during the process and the output is not necessary (set it as FALSE and decrease the memory used).}

\item{parallelize}{if TRUE, parallelize with "doParallel" package the processes (required powerful computer if large AIS dataset and data timestamps to process.)}

\item{nb_cores}{number of cores to used with doParallel.}

\item{outfile}{file to print the logs if parallelize = T.}

\item{QUIET}{if FALSE, print the iterations: either in the console if parallelize = F, or in the file "outfile" if parallelize = T.}
}
\value{
return the input data with the AIS extracted merged in the dataframe: each line of input data is duplicated by timestamp to extract (every "t_gap" number of seconds up to "max_time_diff" number of seconds). All these lines are duplicated for each MMSI present in the area at the moment of the extraction. If no AIS are present in the radius at this moment, the columns dedicated to AIS data are filled with NA, so that no input data and no timestamp to extract is lost.
The output dataframe contains the columns of the input data, the columns of the AIS data (with "ais_" as prefix if the same column is already present in the input data), and the following columns:
\itemize{
\item distance_effort_ais_m: distance (meters) between the data location and the MMSI at this time (filled with NA if no MMSI).
\item timestamp_AIS_to_extract: timestamp for the extraction of the AIS (approximated with "average_at" number of seconds if accelerate = TRUE).
\item diffTime_AIS_extraction_effort: difference (in seconds) between the timestamp to extract (timestamp_AIS_to_extract) and the real data timestamp.
\item datetime_AIS_to_extract: datetime of timestamp_AIS_to_extract.
\item diffTime_AIS_effort: difference, in seconds, between the AIS data and the data timestamp: can be different from diffTime_AIS_extraction_effort due to the parameter "average_at" (that average the timestamp to extract).
\item hour_AIS_to_extract: hour of timestamp_AIS_to_extract
\item time_travelled: number of seconds since the last reception or interpolation of an AIS signal (0 if first reception).
\item distance_travelled:  distance travelled (meters) since the last reception or interpolation of an AIS signal (0 if first reception).
\item speed_kmh: speed (km/h) of the vessels since the last reception or interpolation of an AIS signal.#' id_ais_data_initial: identifier of the row line in the ais data, ordered, corrected and cleaned. Use for internal computation. For interpolated data, id_ais_data_initial is the same than the next real existing line.
\item id_ais_data_initial: identifier of the row in the ordered, corrected and cleaned ais data. Used for internal computation. For interpolated positions, id_ais_data_initial is the same than the next real existing AIS data.
\item station: if TRUE, the MMSI has been identified as a station.
\item high_speed: if TRUE, the MMSI has been identified as an high speed craft (specially used for aircraft).
\item any_NA_speed_kmh: if TRUE, at least one of the speeds of this MMSI has a speed as NA (so distance_travelled or time_travelled has a issue and the AIS data must be checked). Should not occur.
\item n_point_mmsi_initial_data: number of point of the MMSI in the AIS data after have removed the points with inexisting longitude and latitude.
\item id_mmsi_point_initial: identifier for the MMSI point after ordering, correcting and cleaning.
\item speed_kmh_corrected: if TRUE, the speed of the line has been corrected.
\item interpolated: if TRUE, this MMSI position has been interpolated.}
}
\description{
Useful to run the complete process in a single function. A check of intermediate results is recommended, to adapt parameters if needed. Save the intermediate results during the processes. Results from the function MMSI_infos can be merge to this output to add information on vessel type and length.
Advice : if AIS data and data to extract are large, and if the application allows it, run this function in a loop for each day to save memory for computation.
}
\examples{
\dontrun{
data("ais")
data("point_to_extract")

library(dplyr)
library(lubridate)
point_to_extract <- point_to_extract \%>\%
  mutate(timestamp = as.numeric(ymd_hm(datetime)))
ais <- ais \%>\%
  mutate(timestamp = as.numeric(ymd_hms(datetime)))

AIStravel_interpolate_extract(data = point_to_extract,
                              ais_data = ais,
                              mmsi_time_to_order = T,
                              search_into_radius_m = 50000,
                              run_AIStravel = T,
                              save_AIStravel = T,
                              file_AIStravel = "AIStravel",
                              load_existing_files = T,
                              overwrite = F,
                              time_stop = 5*60*60,
                              run_AISinterpolate_at = T,
                              save_AISinterlate_at = T,
                              file_AISinterlate_at = "AISinterpolate_at",
                              correct_speed = T,
                              threshold_speed_to_correct = 100,
                              duplicate_time = F,
                              max_time_diff = 00,
                              t_gap = 10*60,
                              accelerate = F,
                              average_at = 0,
                              filter_station = T,
                              filter_high_speed = T,
                              radius = 200000,
                              run_AISextract_perHour = T,
                              save_AISextract_perHour = T,
                              file_AISextract_perHour = "AISextract",
                              return_merged_all_extracted = T,
                              parallelize = F,
                              nb_cores = NA)}
}
